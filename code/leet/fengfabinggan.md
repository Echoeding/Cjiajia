#### [分发饼干](https://leetcode.cn/problems/assign-cookies/)

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

> ```
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```
>
> ```
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
> ```



#### 自己想法

1. 贪心算法，优先把大块的饼干分给大胃口的孩子
2. 以此类推
3. 但是要思考好，谁是在外面一层循环的问题

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());    //排序

        int cnt=0;
        //先遍历谁的问题
        for(int i=g.size()-1;i>=0;i--){     //胃口
            for(int j=s.size()-1;j>=0;j--){     
                if(g[i]<=s[j]&&s[j]>0){     //找到符合的饼干
                    cnt++;
                    s[j]=-1;    //饼干被吃
                    break;
                }
            }
        }
        return cnt;
        // for(int i=s.size()-1;i>=0;i--){
        //     for(int j=g.size()-1;j>=0;j--){
        //         if(g[j]<=s[i]&&g[j]>0){
        //             cnt++;
        //             g[j]=-1;
                    
        //         }
        //     }
            
        // }
        return cnt;
    }
};
```



#### 查看题解



#### 总结

1. 贪心算法：一对一的分配问题，要考虑好，谁是外面一层循环的问题