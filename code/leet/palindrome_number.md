> 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
>
> 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
>
> 输入：x = 121
> 输出：true
>
> 
>
> 输入：x = -121
> 输出：false
> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数

## 自己想法

执行用时：8 ms, 在所有 C++ 提交中击败了78.27% 的用户

内存消耗：5.7 MB, 在所有 C++ 提交中击败了84.55% 的用户

```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0)
            return false;
        else{
            double num=x;
            double sum=0;
            for(;x!=0;){
                sum=sum*10+x%10;
                x=x/10;
            }
            if(sum==num)
                return true;
            return false;
        }
    }
};
```

看到题目，最好不同int转字符串来做

第一想到的是，双指针，前面+后面，共同匹配，但是这是int啊，太磨叽

然后就考虑到曾经二进制转换的那里，除数，取余数？？嘿，这个想法很不错

但是怎么把取到的余数和首位数字进行比较呢？

那就把进制转换的反过程加入进来，商*10+余数，变回去，然后和原数字比较，嗯，就这个思路了

实现之后，时间和内存都还不错，开始看看题解思路

### 遇到问题

一开始，我是用int类型，显示溢出，我还疑惑，这哪有问题，后来想到9结尾的，开头就是9，会很大呀，就改为了double才没有问题



## 查看题解

1. 看到一个优化，就是还是我的思路，但是可以在除数取余的时候，只循环一半，123321，循环一半的时候，两边数字就都是123，直接判断相等

   ```c++
   class Solution {
   public:
       bool isPalindrome(int x) {
           // 特殊情况：
           // 如上所述，当 x < 0 时，x 不是回文数。
           // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
           // 则其第一位数字也应该是 0
           // 只有 0 满足这一属性
           if (x < 0 || (x % 10 == 0 && x != 0)) {
               return false;
           }
   
           int revertedNumber = 0;
           while (x > revertedNumber) {	//只循环一半的优化
               revertedNumber = revertedNumber * 10 + x % 10;
               x /= 10;
           }
   
           // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
           // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
           // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
           return x == revertedNumber || x == revertedNumber / 10;
       }
   };
   ```

2. 看到题解的思路，之前用int时候，如果反转之后溢出了，那不就肯定不是回文数了吗，直接抛出异常

## 总结

1. 反转全部数字的溢出问题，以及只循环一半的优化思路
2. 当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了