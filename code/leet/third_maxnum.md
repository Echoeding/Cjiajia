> 给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数
>
> ```
> 输入：[3, 2, 1]
> 输出：1
> 解释：第三大的数是 1
> ```
>
> ```
> 输入：[1, 2]
> 输出：2
> 解释：第三大的数不存在, 所以返回最大的数 2
> ```
>
> ```
> 输入：[2, 2, 3, 1]
> 输出：1
> 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
> 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1
> ```

[自己想法](#自己想法)

[查看题解](#查看题解)

[总结](#总结)

## 自己想法

执行用时：4 ms, 在所有 C++ 提交中击败了92.13% 的用户

内存消耗：8.8 MB, 在所有 C++ 提交中击败了83.16% 的用户

```c++
#include<algorithm>

class Solution {
public:
    int thirdMax(vector<int>& nums) {
        sort(nums.rbegin(),nums.rend()); //对其排序，降序 3,2,1
        int i=1;        //作为标记第几个老大
        int num=nums.front();        //当前遍历数字

        for(int e=0;e<nums.size();e++){
            if( nums[e]<=num && i!=3){
                if(nums[e]!=num){   //不相同元素，正常向后推进
                    num=nums[e];
                    i++;
                }
                num=nums[e];        //第一位和num相同，标记不推进
            }
        }
        if(i!=3)
            return nums[0];
        return num;
            
    }
};
```

一开始没啥思路，一开始想遍历三次，`num1`，`num2`....这样标记，似乎有些太蠢了吧！！！

然后想到vector有没有排序函数，就搜到了降序和升序的排序，拍完序之后，就可以类似于“双指针”的思想了吧，一个遍历指针`j`，一个标记大小的指针`i`，让你找到老几都可以

说一下几个点：

用`nums[e]!=num`来判断是否相同元素，相同的话，标记大小的指针是不会++的

但是第一个元素，又需要额外判断，因为刚赋值的时候，一定存在`num==nums[e]`的

所以在`if`内部还有一个判断不相等的条件，就是用于解决首元素的问题



然后就是第一次提交时候，有12个案例没通过

发现在不满足存在第三大的元素的时候，会返回错误，因为此时我的标记指针`i`肯定已经到了末位

如果和上面一样直接返回的话，那么不就是最小的元素了吗？？

所以在返回的时候又加了一个判断语句，如果没到第三大的元素，直接返回首位（此时是降序排列）

## 查看题解

1. 发现用`set`也可以，之前没有了解过`set`的特点，下面总结

   - `set`插入时会自动排序，默认从小到大

   - `set`不允许插入重复元素

   - `set`插入数据的同时，会返回插入结果，是否成功

   - ```c++
     set<int> s1;
     s1.insert(10);			//插入元素
     s1.size();				//个数
     s1.empty();				//判空
     s1.swap();				//交换容器
     s1.erase(pos);			//删除pos迭代器所指的元素
     s1.erase(10);
     s1.erase(begin, end);
     s1.find(key);			//找到则返回该元素的迭代器，没有则s1.end()
     s1.count(key);			//统计个数
     ```

   - `multiset`可以插入重复数据

2. 用set，遍历插入数据，如果size大于3，那么就删掉最小的，最后返回的时候判断一下里面是不是有三个及以上数据即可知道返回什么元素

## 总结

1. 排序+伪“双指针”思想，找到数组中的老几
2. set容器相关特性