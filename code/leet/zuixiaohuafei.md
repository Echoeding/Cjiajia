#### [使用最小的花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

> 给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
> 你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。
>
> 请你计算并返回达到楼梯顶部的最低花费。

> ```
> 输入：cost = [10,15,20]
> 输出：15
> 解释：你将从下标为 1 的台阶开始。
> - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
> 总花费为 15 。
> ```
>
> ```
> 输入：cost = [1,100,1,1,1,100,1,1,100,1]
> 输出：6
> 解释：你将从下标为 0 的台阶开始。
> - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
> - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
> - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
> 总花费为 6 。
> ```



#### 自己想法

1. 动态规划
2. `dp`数组含义为到第i个台阶的花费
3. `dp`数组初始化为`dp[0]=cost[0]`，`dp[1]=cost[1]`
4. `dp[i]`的迭代计算方式是由`dp[i-1]`走一步得到 or `dp[i-2]`走两步得到，取最小值
5. 要注意最后一步到达楼顶时的花费

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n=cost.size();

        vector<int> dp(n+1);
        dp[0]=0;
        dp[1]=0;

        for(int i=2;i<n;i++){
            int num1=dp[i-1]+cost[i-1];
            int num2=dp[i-2]+cost[i-2];
            dp[i]=min(num1,num2);
        }
        int cnt=min(dp[n-1]+cost[n-1],dp[n-2]+cost[n-2]);
        return cnt;

    }
};
```

