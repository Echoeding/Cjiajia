# 第三章 字符串、向量和数组

## 3.1 string

### 3.1.1 定义和初始化

```c++
string s1(s);	//直接初始化
string s2 = s1;		//拷贝初始化
string s3(n, 'c');
string s4("hello");
```

### 3.1.2 对象的操作

- 读取操作时，string对象会自动忽略开头的空白，直到遇见下一处空白为止

```c++
while(cin>>s)	//可以执行重复输入

getline(cin, s);	//读入一行
//直到遇到换行符为止(换行符也被读进来了)，然后把所读的内容存入到string对象中去(不存入换行符)
```



- s.size()函数返回的是一个无符号的整型数

```c++
s.size() < n;	//若n是负数，则比较会自动转换为一个较大的无符号数，所以此表达式一定为trye
```



- 字面值和string对象相加

```c++
string s1 = s + "!";		//正确
string s2 = s1 + s;		//正确
string s3 = "hello" + "world";		//错误，不能把字面值直接相加赋给string对象
string s4 = s1 + "hello" + "world";		
//正确，等价于(s1+"hello")+"world"

string s5 = "hello" + "world" + s1;		//错误，等价于("hello"+"world"+s1)
```

**字符串字面值与string是不同的类型**



### 3.1.3 处理字符

- 处理每个字符

```c++
for(auto s: s1)
```

- 改变字符串中的字符

```c++
for(auto &s : s1)
//要想改变string对象中字符的值，必须把循环变量定义成引用类型
```

- 可以用下标访问

**C++语言规定只有当左侧运算符对象为真时才会检查右侧运算对象的情况**



## 3.2 vector

### 3.2.1 定义和初始化

- 特殊，列表初始化

```c++
vector<string> s={"a", "b"};
//列表初始化，用圆括号即为错误

vector<int> v1(10);		//10个元素
vector<int> v2{10};		//1个元素

vector<string> s1{"hello"};		//1个元素
vector<string> s2("hello");		//错误，直接初始化是对象
vector<string> s3(10);			//10个默认初始化的元素
vector<string> s4{10, "hi"};	//10个hi，和int的区别
```

- **例外情况**

> 拷贝初始化时，只能提供一个初始值

### 3.2.2 添加对象

```c++
push_back();
```

- 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
- 改变对象的auto时，也需要使用&
- size()返回值的类型是由vector定义的size_type类型
- **确定大小之后**才可以使用下标进行访问元素，添加元素



## 3.3 迭代器

### 3.3.1 使用迭代器

- 所有的标准库容器都可以使用迭代器，只有少数几种支持下标访问

```c++
auto b = v.begin(), c = v.end();
//如果容器为空，则begin和end返回同一个迭代器

*b;		//可以获得值，解引用
```

- end()返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作
- 养成使用迭代器和`!=`的习惯，因为大多数迭代器没有定义`<`运算符
- begin和end返回的具体类型由对象是否是常量决定

```c++
auto b = v.cbegin(), c = v.cend();		//返回的一定都是常量，C++11
```



- 结合解引用和成员访问操作

```c++
(*it).empty();		//正确
*it.empty();		//错误

//C++定义了箭头运算符，箭头运算符把解引用和成员访问两个操作结合在一起
it->mem 与 (*it).mem等价
```



- 两个限制

> 1. 不能在for循环中向vector对象添加元素
> 2. 任何一种可能改变vector对象容器的操作，都会使该对象的迭代器失效



### 3.3.2 迭代器运算

```c++
it1 - it2;		//两个迭代器相减，得到之间的距离，是一个有符号数
>、>=、<、<=
```



- **利用迭代器进行二分查找**

```c++
auto beg = v.begin(), end = v.end();
auto mid = v.begin()+(end-beg)/2;
while(mid != end && *mid != target)
    ...
```



## 3.4 数组

