# 第二章 变量和基本类型

## 2.1 基本内置类型

1. long long是C++11新定义的，unsigned int就是无符号数

2. 但是char被分为了char、signed char和unsigned char

   > 字符型的表现形式只有两种，char实际表现为哪种形式是由编译器决定的
   >
   > 所以算术表达式中尽量不要使用char，可能在一些机器上是有符号的，另一些机器是无符号的

3. 执行浮点数运行优先选用double

```c++
bool b = 42;	//b为真
int i = b;
i = 3.14;
double p = i;
unsigned char c = -1;		//假设char占8比特，c为255
signed char c2 = 256;		//假设char占8比特，c2的值未定义
```

> 当我们赋给**无符号数**一个超出它范围的值时，初始值 = 对数值总数取模后的余数
> 当我们赋给**有符号数**一个超出它范围的值时，它的值是不被定义的



4. 含有无符号类型的表达式，有符号数优先转为无符号数，无符号数永远不会小于0，在循环条件判断时要注意
5. 字符和字符串字面值：编译器在每个字符串的结尾处添加一个空字符('\0')，因此字符串字面值的实际长度要比它的内容多1



## 2.2 变量

1. 对象是指一块能存储数据并具有某种数据类型的内存空间
2. 初始化和赋值是两个完全不同的操作
3. **C++11特性**：用花括号来初始化变量——列表初始化，有丢失数据的风险时，编译器将报错不执行

```c++
double num = 3.14;
int a{num}, b{num};		//报错，有丢失数据的风险
int a(num), b = num;	//正确，但是丢失了一部分数值
```



### 2.2.1 变量声明和定义的关系

1. 声明规定了变量的类型和名字，但定义还会申请存储空间，也可能会为变量赋一个初始值

```c++
extern int i;		//声明i
int j;				//定义j
```

2. 但是不要显式的初始化变量

```c++
extern int j = 3;		//定义j，而不是声明j
```

> 变量只能被定义一次，但是可以被声明多次
>
> 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误



### 2.2.2 名字的作用域

1. 作用域中一旦声明某个名字，在其嵌套的所有作用域中都能访问该名字，同时允许在内层作用域中重新定义外层作用域已有的名字



## 2.3 复合类型

### 2.3.1 引用

```c++
int ival = 1024;
int &num = ival;		
int &num2;			//报错，引用必须被初始化
```

> 程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用
>
> 因为引用本身不是一个对象，它只是为一个已经存在的对象起的另一个名字，所以不能定义引用的引用
>
> 引用只能绑定在对象上，不能与某个字面值绑定在一起



### 2.3.2 指针

- **指针和引用的不同点**
  - 指针本身就是一个对象，允许对指针赋值和拷贝，生命周期内可以先后指向不同的对象
  - 指针无需在定义时赋值
  - 一旦定义了引用，就不能令其再绑定到其他对象

```c++
int *a, *p;
int b = 10;
int &c = b;
a = &b;
int *d = &b;
p = a;

cout<<*a<<endl;

//同时，指针和它所指向的对象要严格匹配
//解引用操作只适用于那些确实指向了某个对象的有效指针
```

```c++
//a = &c;		//错误，不能定义指向引用的指针
```



1. 空指针的几种生成方法

```c++
int *p1 = nullptr;		//等价于int *p1 = 0;	
//C++11新标准

int *p2 = 0;		
int *p3 = NULL;		//头文件cstdlib
```

